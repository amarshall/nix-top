#!/usr/bin/env ruby

# frozen_string_literal: true

require "shellwords"
require "optparse"
require "io/wait"

DEFAULTS = {
  delay: 0.5,
  once: false,
}.freeze

options = DEFAULTS.dup

OptionParser.new do |opts|
  opts.banner = "Usage: nix-top [options]"

  opts.on("-d", "--delay [seconds]", Numeric, "In seconds (default: #{DEFAULTS[:delay]})") do |v|
    options[:delay] = v
  end
  opts.on("-1", "--once", "Only run once") do |v|
    options[:once] = v;
  end
end.parse!

VT_CLEAR_LINE=`tput el`
VT_CLEAR_REST=`tput ed`
VT_HOME=`tput cup 0 0`

ETIME_PATTERN = /^((?<days>\d)+-)?((?<hrs>\d+):)?(?<mins>\d+):(?<secs>\d+)$/

def stty(*flags)
  `#{["stty", *flags].shelljoin}`
end

# Returns [width, height] of the terminal.
def size
  `echo 'cols\nlines' | tput -S`.strip.split("\n").map(&:to_i)
end

def build_users
  `getent group nixbld`.strip.split(":").last.split(",")
end

def active_build_users()
  build_users.select do |name|
    `pgrep -fu #{name.shellescape}`
    $? == 0
  end
end

# Returns a mostly correct snapshot of the PIDs for processes building
# things, in a Hash indexed by build user.
def get_processes()
  active_build_users.map do |user|
    pids = `pgrep -u #{user.shellescape}`
        .strip.split("\n")
        .map(&:to_i)
        .sort
    path = get_out_path(user, pids.first)

    {
      user: user,
      path: path,
      pids: pids,
      per_output_infos: per_output_infos(user, pids, path),
    }
  end
end

# Gets either the out path, or an approximation, depending whether
# or not it can peek into processes.
def get_out_path(user, pid)
  begin
  # whew!
  build_dir = `find -L /tmp -maxdepth 1 -user #{user.shellescape} -exec stat --printf '%Z:%n\\n' '{}' ';' | sort -n`
    .strip
    .split("\n")
    .last
    .split(":")
    .last
  rescue
    "(unknown)"
  end
  begin
    file = "#{build_dir}/env-vars"
    # This can fail if the process disappears while trying to read.
    # This is why we rescue everything
    # (This also could fail due to missing `out=` and we get free rescue)
    File.read(file)                          # Reads process' environment
      .split("\n")                           # (which is a null-delimited list)
      .grep(/^declare -x out=/)              # Keep out paths
      .first                                 # Keep the only result
      .split("\"").last                      # Keep only the value
  rescue
    build_dir
  end
end

def per_output_infos(user, pids, path)
  [
    ":: (%s) → %s" % [user, path],
    *(`ps -o uid,pid,ppid,stime,etime,time,command -U "#{user.shellescape}"`.split("\n")),
  ]
end

def parse_etime_to_duration(str)
  ETIME_PATTERN.match(str).named_captures.transform_keys(&:to_sym).transform_values do |val|
    if val
      val = val.sub(/^0+(?!$)/, '')
      val = '0' if val.empty?
      Integer(val)
    else
      0
    end
  end.tap do |duration|
    duration[:hrs] += duration.delete(:days)
  end
end

def duration_to_seconds(duration)
  60 * (duration.fetch(:secs) + (
    60 * (duration.fetch(:mins) + (
      60 * duration.fetch(:hrs)
    ))
  ))
end

def get_duration(output_infos)
  duration = output_infos
    .drop(2)
    .map { |info| parse_etime_to_duration(info.strip.split(/\s+/, 7)[4]) } # get etime
    .max_by { |duration| duration_to_seconds(duration) }

  if duration
    sprintf("%<hrs>02dh%<mins>02dm%<secs>02ds", duration)
      .sub('00h00m', '      ')
      .sub('00h', '   ')
  else
    '         '
  end
end

# A "screenful" of information
# Does not trim output to fit in one terminal screen.
def print_screen()
  processes = get_processes()

  lines = []
  sep = [
    "",
    " * * * ",
    "",
  ]

  lines << "Summary per output"
  lines.concat(processes.map do |process|
    "    %4d (%s) → %s" % [
      process[:pids].length,
      get_duration(process[:per_output_infos]),
      process[:path],
    ]
  end)
  lines.concat(sep)
  lines.concat(processes.map do |process|
    ['', *process[:per_output_infos]]
  end)

  # This is hacky and round-about...
  # but the consumers will assume this gives *lines*.
  # I don't want to ensure everything is already a line.
  # So, uh, joining everything and re-splitting is done for now.
  # TODO : better API for writing a screen.
  lines.flatten.join("\n").split("\n")
end

# Trims the "screenful" to fit into the screen.
def display(screen)
  width, height = size
  screen = screen[0...height].map do |line|
    line[0...width] + VT_CLEAR_LINE
  end.join("\n").strip

  print VT_HOME + screen + VT_CLEAR_REST
end

# ------------------------------------------------------------------------------

# Ensures no backtrace on ^C
Signal.trap("INT") do
  exit
end

at_exit {
  stty($saved_stty)
  puts ""
  exit
}
$saved_stty = stty("-g").strip
stty("-echo", "-icanon")

if options[:once]
  print print_screen.join("\n").strip
  exit
else
  display(print_screen)
end

while true do
  if $stdin.wait_readable(options[:delay]) then
    exit if $stdin.readpartial(4096).include? "q"
  end

  display(print_screen)
end
